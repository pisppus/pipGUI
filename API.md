# Логотип

## 1. Вызов логотипа

Как мы вызываем её в прошивке:

```cpp
ui.showLogo(
    "PISPPUS",               // 1. Заголовок (title)
    "Digital Thermometer" ,  // 2. Подзаголовок (subtitle, можно опустить)
    SlideUp,                 // 3. Тип анимации (animation, можно None/FadeIn/LightFade/SlideUp/ZoomIn)
    TFT_WHITE,               // 4. Цвет текста (fgColor)
    TFT_BLACK,               // 5. Цвет фона (bgColor)
    1500,                    // 6. Длительность анимации в мс (durationMs)
    160,                     // 7. X центра блока (x)
    40                       // 8. Y верха блока (y)
);
```

### Что за что отвечает

- **`title`** - главная строка, всегда рисуется.
- **`subtitle`** - вторая строка под заголовком. Если пустая строка, блок считается однострочным.
- **`animation`** - как появится логотип:
  - `None` - без анимации, логотип рисуется сразу.
  - `FadeIn` - плавный проявляющийся текст.
  - `LightFade` - текст сразу есть, плавно меняется только яркость подсветки.
  - `SlideUp` - блок выезжает снизу вверх.
  - `ZoomIn` - текст плавно выезжает масштабированием (zoom 0.5x → 1.0x) с мягким проявлением по цвету (bezier‑кривая).
- **`fgColor`** - цвет текста (RGB565).
- **`bgColor`** - цвет заливки фона под логотипом.
- **`durationMs`** - сколько длится анимация. 0 или очень маленькое значение ≈ мгновенный показ.
- **`x`** - горизонтальная позиция центра логотипа. `-1` = по центру экрана.
- **`y`** - вертикальная позиция **верха блока** логотипа. `-1` = автоматически по центру.

## 2. Шрифты для логотипа

Внутри `GUI` есть отдельные шрифты для заголовка и подзаголовка логотипа.

- **`logoTitleFont(font)`** - шрифт только для заголовка лого (bitmap‑шрифт LovyanGFX).
- **`logoSubtitleFont(font)`** - шрифт только для подзаголовка.
- **`logoFonts(titleFont, subtitleFont)`** - сразу задать оба шрифта.

- **`logoTitleFont(font, sizePx)`** - использовать TTF для заголовка, высота `sizePx` пикселей.
- **`logoSubtitleFont(font, sizePx)`** - использовать TTF для подзаголовка, высота `sizePx`.
- **`logoFonts(titleFont, subtitleFont, sizeTitlePx, sizeSubtitlePx)`** - сразу задать шрифты и размеры для обеих строк.

Если шрифты не заданы, используются стандартные шрифты **LovyanGFX** (`setTextFont(4)` для заголовка и `setTextFont(2)` для подзаголовка).

Пример настройки бут‑логотипа с TTF:

```cpp
ui.loadBuiltinTTF(KronaOne);
ui.logoFonts(nullptr, nullptr, 36, 24);
ui.showLogo("PISPPUS", "Digital Thermometer", ZoomIn, TFT_WHITE, TFT_BLACK, 2000);
```

---

# TTF‑шрифты и пресеты текста

## 1. Загрузка TTF

Базовый способ (сырые данные TTF в памяти):

```cpp
ui.loadTTF(data, size);
```

Упрощённый способ для встроенных (embedded) шрифтов:

```cpp
ui.loadBuiltinTTF(WixBold);
```

`BuiltinTTF`:

- `KronaOne`
- `WixRegular`
- `WixMedium`
- `WixSemiBold`
- `WixBold`

## 2. Пресеты размеров текста

Можно настроить размеры (в пикселях) под свои экраны:

```cpp
ui.configureTextStyles(
    24, // H1
    18, // H2
    14, // Body
    12  // Caption
);
```

`TextStyle`:

- `H1`
- `H2`
- `Body`
- `Caption`

Применить стиль (меняет текущий размер TTF‑шрифта):

```cpp
ui.setTextStyle(H1);
```

Нарисовать текст стилем в один вызов:

```cpp
ui.drawTTFTextStyle("Hello", H2, -1, 30, TFT_WHITE, Center);
```

Если `bgColor == -1`, используется фон GUI.

---

# Рисование фигур

## fillRect

Рисует заполненный прямоугольник с поддержкой автопозиционирования:

```cpp
ui.fillRect(
    -1,           // X координата (-1 = центрировать по горизонтали)
    50,           // Y координата (-1 = центрировать по вертикали)
    200,          // Ширина
    100,          // Высота
    TFT_BLUE      // Цвет заливки (RGB565)
);
```

---

# HAL платформа (pipCore)

`pipGUI` не должен знать ничего про железо напрямую.
Вся платформо-зависимая часть (время, подсветка/PWM, сохранение яркости, настройка OpenFontRender) живёт в `pipCore`.

## 1. Подключение платформы в прошивке

Для ESP32 используй готовую реализацию:

```cpp
#include <pipGUI/core/api/pipGUI.h>
#include <pipCore/Platforms/ESP32/GUI.h>

static pipcore::Esp32GuiPlatform platform;
static pipgui::GUI ui;

void setup() {
  ui.setPlatform(&platform);
  ui.configureDisplay(/* ... */);
  ui.begin(/* ... */);
}
```

Важно:

- `setPlatform(...)` должен быть вызван ДО `begin()`.
- Если платформа не задана, `setBacklightPin(...)` ничего не настроит.

## 2. Как сделать свою платформу

Сделай класс-наследник `pipcore::GuiPlatform` и реализуй минимум `nowMs()`.
Остальное опционально.

```cpp
class MyPlatform final : public pipcore::GuiPlatform {
public:
  uint32_t nowMs() override { return myMonotonicMs(); }
  void setBacklightPercent(uint8_t percent) override { myBacklight(percent); }
};
```

---

# Яркость

- **`setBacklightCallback(cb)`** - передаёте функцию, которая **физически выставляет яркость** (PWM, драйвер и т.п.).
  - Аргумент `level` - `0..100` процентов яркости. 0 - экран погашен, 100 - логический максимум.
- **`setBacklightPin(pin, channel = 0, freqHz = 5000, resolutionBits = 12)`** - настройка подсветки через HAL платформу.
  - на ESP32 это реализовано в `pipcore::Esp32GuiPlatform` через LEDC;
  - в прошивке достаточно вызвать `ui.setPlatform(&platform)` и затем `ui.setBacklightPin(pin)`.
- **`setMaxBrightness(percent)`** - задаёте **глобальный максимум** яркости в процентах `0..100` (например, можно ограничить максимум 70%).
- **`maxBrightness()`** - позволяет **прочитать текущее значение максимума** (в процентах).

Таким образом:

- `GUI` сам считает анимацию и даёт вам **уровень яркости** `0..maxBrightness()` в процентах `0..100`;
- ваш код через колбэк **выставляет физическую яркость**, переводя проценты в конкретные единицы ШИМ/драйвера;
- при использовании `setBacklightPin(...)` на ESP32 платформа (`pipCore`) сама переводит проценты в PWM и сохраняет выбранный максимум яркости между перезагрузками.

---

# Экранные меню

Внутри `GUI` есть простая система **экранов** (screen), каждый экран - это обычная функция‑колбэк.

```cpp
void screenMain(GUI &ui)    { /* рисуем главный экран */ }
void screenSettings(GUI &ui){ /* меню настроек        */ }
void screenInfo(GUI &ui)    { /* инфо‑экран           */ }

void setup() {
  // ... инициализация GUI ...

  ui.regScreen(0, screenMain);     // id = 0
  ui.regScreen(1, screenSettings); // id = 1
  ui.regScreen(2, screenInfo);     // id = 2

  ui.setScreen(0);   // стартовый экран
}
```

- `regScreen(id, cb)` - привязка числового id к функции экрана.
- `setScreen(id)` - мгновенно переключиться на экран `id` (без анимации).
- `nextScreen()` / `prevScreen()` - перейти на следующий/предыдущий зарегистрированный экран.
- `currentScreen()` - вернуть текущий id.

## 1. Как обновляется экран внутри `loop()`

В основном цикле нужно просто звать `ui.loop()` и по необходимости просить перерисовку:

```cpp
void loop() {
  ui.loop();          // GUI сам проверит, нужно ли перерисовать текущий экран

  // Пример: переключение экранов по кнопкам
  if (nextButtonPressed)
    ui.nextScreen();  // запустит анимацию перехода (если включена)

  if (needUpdateClock) {
    ui.setStatusBarText("pipGUI", timeString, "");
    ui.requestRedraw();   // попросили перерисовку текущего экрана
  }
}
```

- Экран будет перерисован, когда:
  - вы сменили экран (`setScreen/nextScreen/prevScreen`),
  - вызвали `requestRedraw()`,
  - или когда идёт внутренняя анимация (логотип, ошибка, уведомление, переход).

## 2. Анимации переходов между экранами

Помимо анимации логотипа, в `GUI` есть анимации переходов между экранами.

```cpp
ui.setScreenAnimation(
    Slide, // тип анимации
    250    // длительность в мс
);
```

- `None` - без анимации, мгновенная смена экрана.
- `Slide` - плавный слайд между экранами с лёгким масштабированием (если спрайты доступны).

- создаёт снимок старого и нового экранов во внутренних спрайтах;
- крутит анимацию в `ui.loop()` до завершения;
- затем фиксирует новый текущий экран.

Если спрайты нельзя создать (не хватает памяти), библиотека автоматически откатывается на простой переход без анимации.

---

# Списочные меню

`GUI` умеет рисовать вертикальные списки пунктов в виде карточек с заголовком и описанием.

## 1. Конфигурация списка на экране

```cpp
void setupMainMenu()
{
    ui.configureListMenu(
        SCREEN_MAIN_MENU,  // экран, где будет список
        SCREEN_HOME,       // родительский экран (назад по long press PREV)
        {
            { "Settings", "Device configuration", SCREEN_SETTINGS },
            { "About",    "Firmware info",        SCREEN_ABOUT    },
            { "Restart",  "Reboot device",        SCREEN_REBOOT   },
        }
    );
}
```

Внутри `configureListMenu` библиотека:

- копирует `title/subtitle/targetScreen` во внутренний буфер;
- сбрасывает выделение, скролл и внутренние флаги;
- если стиль не задан, подбирает базовый по цвету фона.
  Объявлять `struct ListMenuItemDef` вручную не нужно —
  она уже определена внутри `GUI`, вы просто передаёте список
  элементов в фигурных скобках, как в примере выше.

## 3. Стиль карточек списка

```cpp
ui.setListMenuStyle(
    SCREEN_MAIN_MENU,
    ui.rgb(12, 12, 12),  // cardColor: фон невыделенной карточки
    ui.rgb(0, 130, 220), // cardActiveColor: фон выделенной карточки
    8,                   // spacing: расстояние между карточками по вертикали
    10,                  // radius: радиус скругления
    0,                   // cardWidth: 0 = авто (оставить по ~5 px отступа слева/справа)
    0,                   // cardHeight: 0 = авто (по умолчанию ≈50 px, с адаптацией под высоту экрана)
    0,                   // titleFontPx: 0 = авто
    0,                   // subtitleFontPx: 0 = авто (≈70% от заголовка)
    0,                   // lineGapPx: 0 = авто (≈ title/3)
    Cards                 // mode: Cards / Plain
);
```

Режимы списка:

- `Cards` — карточки с заголовком и (если `subtitle` не пустой) описанием.
- `Plain` — упрощённый список: **только заголовки** и **активная плашка**.

Поля стиля:

- `cardColor` - цвет невыделенной карточки.
- `cardActiveColor` - цвет выделенной карточки.
- `spacing` - расстояние между карточками по вертикали.
- `radius` - радиус скругления.
- `cardWidth` - явная ширина карточки в пикселях (`0` = авто‑подбор от ширины экрана, с отступами ≈5 px по краям).
- `cardHeight` - явная высота карточки (`0` = базовое значение ≈50 px с авто‑адаптацией по высоте экрана).
- `titleFontPx` - размер TTF‑шрифта заголовка (0 = авто, как в списочном меню).
- `subtitleFontPx` - размер TTF‑шрифта описания (0 = авто, ≈70% от заголовка).
- `lineGapPx` - расстояние между заголовком и описанием (0 = авто, ≈ title/3).

Если любой из этих параметров равен `0`, библиотека **сама подбирает** значение:

- без описания: заголовок ~20 px;
- с описанием: заголовок ~18 px, описание ~70% от заголовка, зазор ~⅓ от размера заголовка.

При смене стиля библиотека очищает кеш отрисовки списка, чтобы избежать артефактов.

## 4. Обработка ввода (навигация по списку)

```cpp
// Опрашиваем физические кнопки в loop()
bool nextDown = btnNext.isDown();  // "вперёд" / вниз по списку
bool prevDown = btnPrev.isDown();  // "назад" / вверх по списку

// События короткого клика (по желанию)
bool nextPressed = btnNext.wasPressed();
bool prevPressed = btnPrev.wasPressed();

ui.handleListMenuInput(
    SCREEN_MAIN_MENU,  // screenId
    nextPressed,
    prevPressed,
    nextDown,
    prevDown
);
```

Поведение по умолчанию:

- Короткое нажатие **NEXT** - перейти к следующему пункту (циклически по кругу).
- Короткое нажатие **PREV** - перейти к предыдущему пункту (тоже циклично).
- Долгое удержание **NEXT** (≈400 мс) - открыть экран `targetScreen` для текущего пункта.
- Долгое удержание **PREV** (≈400 мс) - вернуться на `parentScreen`.

При изменении выбранного пункта `GUI` помечает активность скролла (для анимации скролл-бара)
и вызывает `requestRedraw()`, чтобы экран перерисовался.

## 5. Отрисовка списка внутри экрана

```cpp
void screenMainMenu(GUI &ui)
{
    ui.renderListMenu(SCREEN_MAIN_MENU);
}
```

- `renderListMenu(screenId)` сам рассчитывает геометрию карточек с учётом статус-бара и размера экрана;
- поддерживает плавный вертикальный скролл (карточки выезжают/заезжают мягко);
- центрирует блок списка по горизонтали.

### 3.6. Кеширование TTF-отрисовки

Если в `GUI` загружен TTF-шрифт через `loadTTF`,
список использует внутренний кеш отрисованных карточек:

- для каждого пункта меню создаются до **двух** буферов: обычное (`normal`) и активное (`active`) состояние;
- карточка один раз отрисовывается во внутренний спрайт: фон + **заголовок TTF** + **описание TTF**;
- пиксели спрайта сохраняются в `uint16_t`-буфер и дальше просто бласятся через `pushImage` при скролле;
- при изменении размера карточки или конфигурации списка кеш автоматически очищается и пересоздаётся.

Если TTF не загружен или не хватает памяти под кеш, `renderListMenu` автоматически откатывается
к отрисовке через обычные bitmap-шрифты LovyanGFX (по одному вызову на заголовок и описание).

---

# Плиточные меню

Плиточное меню - это сетка карточек (тайлов) с заголовком и, опционально, описанием. Структура и логика максимально похожи на списочное меню, но пункты раскладываются по рядам и колонкам.

## 1. Конфигурация плиточного меню на экране

```cpp
void setupTileMenu()
{
    ui.configureTileMenu(
        SCREEN_TILE_MENU,  // экран, где будет сетка плиток
        SCREEN_HOME,       // родительский экран (назад по long press PREV)
        {
            { "Main",    "Главный экран",     SCREEN_MAIN },
            { "Settings","Настройки",          SCREEN_SETTINGS },
            { "Info",    "Инфо",               SCREEN_INFO },
            { "Graph",   "Графики",            SCREEN_GRAPH },
        }
    );
}
```

Внутри `configureTileMenu` библиотека:

- копирует `title/subtitle/targetScreen` во внутренний буфер;
- сбрасывает выделенный индекс и флаги long press;
- если стиль не задан, подбирает базовые цвета и отступы по фону экрана.

## 2. Стиль плиток

```cpp
ui.setTileMenuStyle(
    SCREEN_TILE_MENU,
    ui.rgb(16, 16, 16),   // cardColor: фон обычной плитки
    ui.rgb(0, 130, 220),  // cardActiveColor: фон выбранной плитки
    13,                     // radius: радиус скругления
    10,                     // spacing: зазор между плитками (и по X, и по Y)
    2,                      // columns: сколько плиток в ряд (0/1 = авто)
    100,                    // tileWidth: ширина плитки (0 = авто по содержимому)
    70,                     // tileHeight: высота плитки (0 = авто по содержимому)
    20,                     // titleFontPx: размер шрифта заголовка (0 = авто)
    14,                     // subtitleFontPx: размер подзаголовка (0 = авто)
    5,                      // lineGapPx: расстояние между строками (0 = авто)
    TextSubtitle);          // режим содержимого (заголовок + подзаголовок)
```

Поля стиля:

- `cardColor` - цвет обычной плитки.
- `cardActiveColor` - цвет выбранной плитки.
- `radius` - радиус скругления углов.
- `spacing` - расстояние между плитками по горизонтали и вертикали.
- `columns` - сколько плиток рисовать в одной строке. При `0` или `1` библиотека воспринимает это как одну колонку.
- `tileWidth` - явная ширина плитки (`0` = авто‑подбор по ширине области + учёт `columns` и `spacing`).
- `tileHeight` - явная высота плитки (`0` = авто‑подбор по высоте области + учёт количества рядов и `spacing`).
- `titleFontPx` - размер TTF‑шрифта заголовка (0 = авто, как в списочном меню).
- `subtitleFontPx` - размер TTF‑шрифта описания (0 = авто, ≈70% от заголовка).
- `lineGapPx` - расстояние между заголовком и описанием (0 = авто, ≈ title/3).
- `contentMode` - режим содержимого:
  - `TextOnly` - только заголовок;
  - `TextSubtitle` - заголовок + подзаголовок (если `subtitle` не пустой).

Плитки автоматически раскладываются по сетке `rows x columns`, сетка центрируется по области экрана **с учётом статус‑бара**, как и списочное меню.

## 3. Обработка ввода для плиточного меню

```cpp
bool nextDown = btnNext.isDown();
bool prevDown = btnPrev.isDown();

bool nextPressed = btnNext.wasPressed();
bool prevPressed = btnPrev.wasPressed();

ui.handleTileMenuInput(
    SCREEN_TILE_MENU,
    nextPressed, prevPressed,
    nextDown,
    prevDown
);
```

Поведение по умолчанию такое же, как у списочного меню:

- короткое нажатие **NEXT** - перейти к следующей плитке (по списку, по кругу);
- короткое нажатие **PREV** - перейти к предыдущей плитке;
- долгое удержание **NEXT** (≈400 мс) - открыть экран `targetScreen` выделенной плитки;
- долгое удержание **PREV** (≈400 мс) - вернуться на `parentScreen`.

## 4. Отрисовка плиточного меню внутри экрана

```cpp
void screenTileMenu(GUI &ui)
{
    ui.renderTileMenu(SCREEN_TILE_MENU);
}
```

- `renderTileMenu(screenId)` рассчитывает размеры плиток и сетки из стиля и размеров экрана;
- сетка центрируется по доступной области, тайлы получают автоматику по цвету обводки (слегка светлее фона);
- текст внутри плиток рисуется либо TTF‑шрифтами (если загружены), либо bitmap‑шрифтами LovyanGFX.

## 5. Кастомная раскладка плиток (layout-конструктор)

Если стандартной сетки `rows x columns` недостаточно, можно задать свою раскладку через сетку layout
и указать для каждого пункта меню его прямоугольник (позицию и span в клетках).

```cpp
ui.setTileMenuLayout(
    SCREEN_TILE_MENU,
    2, 3, // layoutCols, layoutRows
    {
        {0, 0, 2, 1}, // item 0: col,row,colSpan,rowSpan
        {0, 1, 1, 1}, // item 1
        {0, 2, 1, 1}, // item 2
        {1, 1, 1, 2}, // item 3
    }
);
```

### Как это работает

- **[сетка]** `layoutCols x layoutRows` — это «виртуальная» таблица клеток.
- **[привязка]** каждая плитка `itemIndex` берёт свою геометрию из `tiles[itemIndex]`.
- **[прямоугольник]** `TileLayoutCell{col,row,colSpan,rowSpan}` означает: плитка начинается в клетке `(col,row)` и занимает `colSpan` клеток по X и `rowSpan` клеток по Y.

  Ментальная модель — это обычная матрица:

  `layoutCols = 2`, `layoutRows = 3`

  ```
  row=0: (0,0) (1,0)
  row=1: (0,1) (1,1)
  row=2: (0,2) (1,2)
  ```

  Где:

  - `col` растёт слева направо
  - `row` растёт сверху вниз

- **[размеры]** сначала вычисляется размер одной клетки (`unitW/unitH`) из доступной области экрана и `spacing`.
  Затем реальный прямоугольник плитки считается так:
  - `tileW = colSpan*unitW + (colSpan-1)*spacing`
  - `tileH = rowSpan*unitH + (rowSpan-1)*spacing`
- **[границы]** если вы указали выход за границы сетки — библиотека подрежет `colSpan/rowSpan`, чтобы плитка не выходила.
- **[пересечения]** библиотека **не проверяет** пересечения плиток между собой. Если два прямоугольника перекрываются — они будут нарисованы поверх друг друга (по порядку `itemIndex`).

Где `TileLayoutCell`:

- `col` — колонка (0..layoutCols-1)
- `row` — строка (0..layoutRows-1)
- `colSpan` — сколько колонок занимает плитка (минимум 1)
- `rowSpan` — сколько строк занимает плитка (минимум 1)

Если `layoutCols/layoutRows` равны 0, кастомная раскладка выключается и используется обычная сетка `rows x columns`.

### Примеры

- **[grid]** обычная сетка (tile menu) — задаётся через `setTileMenuStyle(... columns=2 ...)`
- **[layout]** «2 маленьких слева + 1 большая справа» — задаётся через `setTileMenuLayout(... 2x3 ...)`
- **[4 cols]** «4 плитки в ряд» — задаётся через `setTileMenuStyle(... columns=4 ...)`

---

# Графики

В `GUI` есть готовый модуль графика с сеткой и несколькими линиями.
Состояние графика (геометрия, авто‑масштаб и т.п.) библиотека хранит **внутри себя для каждого экрана**.

## 1. Фон и сетка графика:

```cpp
ui.drawGraphGrid(
    center, center,        // x, y: можно указать center, чтобы выровнять по экрану
    graphW, graphH,        // ширина и высота рамки
    13,                    // радиус скругления
    LeftToRight,           // направление движения (LeftToRight / RightToLeft / Oscilloscope)
    ui.rgb(0, 0, 0),       // цвет фона
    ui.rgb(57, 57, 57),    // цвет сетки и рамки
    1.0f                   // скорость (зарезервировано под анимацию сетки)
);
```

- При `x == center`/`y == center` график автоматически центрируется по доступной области экрана.

- **`dir` (GraphDirection)**:
  - `LeftToRight` - классический режим: новые значения добавляются справа, график «едет» влево;
  - `RightToLeft` - зеркально: новые значения добавляются слева;
  - `Oscilloscope` - режим осциллографа: буфер заполняется слева направо и линия перерисовывается целиком по накопленным точкам (удобно для разового построения пачки сэмплов).

## 2. Авто‑масштабирование

```cpp
ui.setGraphAutoScale(true);  // включить авто‑масштаб для ТЕКУЩЕГО экрана
```

При включённом авто‑масштабе функция `drawGraphLine` сама подбирает вертикальный диапазон `min/max` на основе данных и плавно подстраивает его со временем, чтобы график не дёргался.

Если нужно жёстко задать диапазон (например, 0..100), авто‑масштаб можно выключить:

```cpp
ui.setGraphAutoScale(false);
```

## 3. Линии графика

Библиотека сама хранит историю значений **для каждого экрана и для каждой линии** во внутренних буферах.

Поддерживается до **5 линий** на экран (`lineIndex` от `0` до `4`). Номера больше 4 просто игнорируются.

```cpp
// Где‑то в update/loop, когда есть новое значение
int16_t value = readSensorMv();  // пример: напряжение уже приведено к мВ

ui.drawGraphLine(
    0,                     // lineIndex: номер линии (0..4)
    value,                 // новое значение, которое нужно добавить на график
    ui.rgb(255, 0, 0),     // цвет линии
    0, 100                 // базовый диапазон значений (при авто‑масштабе служит стартовым min/max)
);
```

- Каждый вызов `drawGraphLine(lineIndex, value, ...)` **добавляет точку** во внутренний кольцевой буфер
  выбранной линии и **сразу перерисовывает** ломаную по последним N точкам.
- Количество хранимых точек примерно равно ширине графика по X – лишние старые значения постепенно выкидываются.
- При `setGraphAutoScale(true)` реальные `min/max` считаются по этим данным с небольшим запасом и
  плавно подстраиваются между кадрами, чтобы график не дёргался.
- При `setGraphAutoScale(false)` используется ровно тот диапазон, который вы передали в `valueMin/valueMax`.

---

# Статус‑бар

Статус‑бар - это узкая панель (по умолчанию сверху), которая всегда рисуется поверх экранов и учитывается при центрировании текста, графиков и уведомлений.

## 1. Включение и настройка

```cpp
ui.configureStatusBar(
    true,               // true/false - включён ли бар
    ui.rgb(0, 0, 0),    // bgColor - цвет фона
    18,                 // height - высота/толщина бара (для top/bottom) или ширина (для left/right)
    Top                 // позиция: Top / Bottom / Left / Right
);
```

Внутри:

- сохраняется флаг включения, высота и позиция;
- **автоматически подбирается цвет текста** (чёрный/белый) по яркости фона.

## 2. Текст и TTF‑шрифт в статус‑баре

```cpp
ui.setStatusBarText(
    "pipGUI", // текст слева
    "12:34",  // по центру
    ""        // справа (можно оставить пустым)
);
```

- Цвет текста берётся из авто‑подбора в `configureStatusBar`.
- Если TTF‑шрифт загружен через `loadTTF`, статус‑бар рисует текст TTF‑шрифтом.
- Высота TTF‑шрифта подбирается автоматически из высоты бара (`height`), чтобы текст аккуратно вписывался по вертикали.
- Если TTF не загружен, используется встроенный шрифт LovyanGFX (эквивалент `setTextFont(1)`).

## 3. Встроенный индикатор батареи

```cpp
// Процент заряда 0..100, стиль - полоска
ui.setStatusBarBattery(100, Bar);

// Цифровой режим: число внутри батарейки
ui.setStatusBarBattery(87, Numeric);

// Спрятать батарейку
ui.setStatusBarBattery(-1); // level < 0 => Hidden
```

- **Bar** - прямоугольная «банка» с заливкой по уровню заряда.
- **Numeric** - внутри батарейки рисуется число процента.
- **Hidden** - батарейка не рисуется.
- Корпус и обводка батарейки используют тот же цвет, что и текст бара.
- При уровне `<= 20%` заливка становится красной, иначе - зелёной.
- Индикатор всегда прижат к правому краю статус‑бара; левее него размещаются правые иконки и текст `right`.

## 4. Иконки в статус‑баре

Статус‑бар умеет рисовать небольшие RGB565‑иконки слева, по центру и справа:

```cpp
extern const uint16_t wifiIcon16x16[];

ui.clearStatusBarIcons();
ui.addStatusBarIcon(Left, wifiIcon16x16, 16, 16);
```

Позиции:

- `Left`
- `Center`
- `Right`

- Массив `bitmap` - это сырые пиксели RGB565 (`w*h` элементов).
- Левые иконки рисуются от левого края внутрь, перед левым текстом.
- Правые иконки - слева от батарейки (если она включена) или от правого края.
- Центральные иконки выравниваются как единый блок с центральным текстом `center`.

## 5. Кастомный отрисовщик (для продвинутых кейсов)

```cpp
void statusBarCustom(GUI &ui, int16_t x, int16_t y, int16_t w, int16_t h)
{
  // x, y, w, h - реальные координаты и размер бара
  auto t = ui.getDrawTarget();
  // пример: тонкая линия-подчёркивание снизу
  t->drawLine(x, y + h - 1, x + w, y + h - 1, TFT_DARKGREY);
}

ui.setStatusBarCustom(statusBarCustom);
```

- Сначала библиотека сама заливает фон, рисует текст `left/center/right`, иконки и батарейку.
- Затем вызывает ваш колбэк, чтобы вы могли дорисовать что‑то поверх.
- В большинстве случаев достаточно встроенных иконок и батарейки, кастомный рисовальщик нужен только для особых эффектов.

## 6. Как статус‑бар влияет на верстку

После вызова `configureStatusBar(...)` библиотека **сама учитывает панель** во всех ключевых местах:

- `drawTTFText`:

  - при `x == -1` текст центрируется по горизонтали **внутри доступной ширины** (с учётом бара слева/справа);
  - при `y == -1` центрируется по вертикали **внутри доступной высоты**, вычитая бар сверху/снизу.

- `drawGraphGrid`:

  - при `x == center`/`y == center` график центрируется во внутренней области экрана, исключая статус‑бар по соответствующей стороне.

- уведомления (`showNotification`) рисуют карточку по центру свободной области, не перекрывая бар.

Код экрана не знает ни про высоту, ни про позицию статус‑бара - `GUI` сам сдвигает контент так, чтобы всё выглядело аккуратно.

---

# Уведомления

В `GUI` есть красивая система **модальных уведомлений**:

### 1. showNotification

```cpp
// Краткий вызов: только заголовок и текст
ui.showNotification("Settings", "Auto notification");

// Расширенный вызов с кнопкой, задержкой и типом
ui.showNotification(
    "Settings",           // 1. Заголовок
    "Auto notification",  // 2. Описание под заголовком
    "OK",                 // 3. Текст кнопки (по умолчанию "OK")
    10,                   // 4. сколько секунд ждать до разблокировки кнопки
    Warning               // 5. тип уведомления (Normal/Warning/Error)
);
```

- Можно вызывать из любого места (например, через таймер после входа на экран настроек).
- Если уведомление уже активно, повторный вызов **обновит текст**, не перезапуская анимацию появления.
  Для более важных уведомлений можно **заблокировать кнопку** на несколько секунд и показать обратный отсчёт.

### 2. notificationActive

```cpp
if (!ui.notificationActive()) {
  // здесь обычная логика переключения экранов, обработки кнопок и т.п.
}
```

---

# Ошибки

Экран ошибок перекрывает всё приложение и рисуется до тех пор, пока ошибка активна.

## 1. Типы ошибок

```cpp
ui.showError("Low battery", "Please charge", Warning);
```

- `Warning` – мягкая ошибка, которую можно **закрыть кнопкой OK**.
- `Crash` – критическая ошибка, экран нельзя закрыть кнопками (ожидается перезагрузка/фикс прошивки).


## 2. showError

```cpp
void showError(title, message, type, "TEXT");
```

- `title` – заголовок ошибки.
- `message` – деталь ошибки.
- `type` – тип ошибки (Warning/Crash).
- `TEXT` – текст кнопки для `Warning`. Если параметр не передать, по умолчанию будет `"OK"`.

### Логика
- Добавляет запись в очередь ошибок и включает экран ошибок (если он ещё не активен).
- Для нескольких ошибок типа `Crash` можно листать карточки с помощью `nextError()`.
- Для `Warning` на экране рисуется большая иконка, заголовок/деталь и кнопка снизу.

Пример из демо (критические ошибки):

```cpp
if (!g_errorDemoActive) {
    ui.showError("LittleFS mount failed!", "Code: 0xLFS_MNT", Crash);
    ui.showError("Sprite creation failed!", "Code: 0xSPR_MEM", Crash);
    ui.showError("No profiles found!",   "Code: 0xNOPROF",   Crash);
    g_errorDemoActive = true;
} else {
    ui.nextError(); // перелистнуть на следующую Crash-ошибку
}
```

Пример некритической ошибки (с кнопкой по умолчанию `OK`):

```cpp
// На том же экране, по другой кнопке
if (prevPressed && !ui.errorActive()) {
    ui.showError("Low battery", "Please charge device", Warning);
}
```

Пример с кастомным текстом кнопки:

```cpp
// Кнопка будет с надписью "Ignore"
ui.showError("Low battery", "Please charge device", Warning, "Ignore");
```

## 3. Цикл ошибок и кнопка OK

```cpp
bool errorActive() const;
void setErrorButtonDown(bool down);
void nextError();
```

- `errorActive()` – возвращает, активен ли сейчас экран ошибок.
- `setErrorButtonDown(down)` – сообщает библиотеке, нажата ли физическая кнопка, привязанная к `OK`.
  - Реагирует **только** для `Warning`; для `Crash` вызов игнорируется.
  - При отпускании кнопки (`down` изменился с `true` на `false`) ошибка типа `Warning` закрывается.
- `nextError()` – листает вперёд по очереди **критических** ошибок (`Crash`). Для `Warning` не используется.

Типичный фрагмент в `loop()` прошивки:

```cpp
void loop() {
    ui.loop();

    bool nextPressed = btnNext.wasPressed();
    bool prevPressed = btnPrev.wasPressed();

    if (ui.errorActive()) {
        // тот же физический PREV используется как OK
        ui.setErrorButtonDown(btnPrev.isDown());
    } else if (ui.notificationActive()) {
        ui.setNotificationButtonDown(btnPrev.isDown());
    }
}
```

- Пока `errorActive() == true`, внутри `ui.loop()` рисуется только экран ошибок (плюс, при наличии, уведомление сверху).
- При закрытии некритической ошибки (`Warning`) флаг `errorActive()` сбрасывается, и нормальный рендер экранов возобновляется.

---

# Универсальные кнопки

В `GUI` есть общий визуальный модуль кнопки, который можно переиспользовать на любых экранах.

Идея:

- внешняя логика знает только, включена ли кнопка и нажата ли сейчас;
- библиотека сама рисует анимацию и считает цвета.

## 1. Состояние кнопки

Обычно в прошивке достаточно просто объявить состояние и включить его:

```cpp
static ButtonVisualState mainBtn;  // всё по нулям по умолчанию
void setup() {
  mainBtn.enabled = true;          // логически включили кнопку
}
```

Внутренние поля (`pressLevel`, `fadeLevel`, `prevEnabled`) библиотека ведёт сама.

## 2. Обновление анимации

```cpp
bool updateButtonPress(ButtonVisualState &state, bool isDown);
```

- Вызывается в `loop()` для каждой визуальной кнопки.
- `isDown` - текущее состояние физической кнопки (`true`, пока держишь).

Если кнопка отключена (`state.enabled == false`) или включён режим загрузки (`state.loading == true`), накопленное нажатие быстро сбрасывается, чтобы не было «залипания» анимации.

## 3. Отрисовка кнопки

```cpp
void drawButton(label, x, y, w, h, baseColor, radius, ButtonVisualState &state);

// Вариант с иконкой слева от текста
void drawButton(label,
                const uint16_t *iconBitmap, uint8_t iconW, uint8_t iconH,
                x, y, w, h,
                baseColor, radius,
                ButtonVisualState &state);
```

- `label` - текст;
- `x/y/w/h` - геометрию (`x`/`y` можно поставить `center`, чтобы выровнять по экрану);
- `baseColor` - основной цвет кнопки;
- `radius` - радиус скругления;
- `state` - актуальное состояние, обновлённое через `updateButtonPress`.

Внутри `drawButton`:

- по `pressLevel` кнопка чуть уменьшается и темнеет;
- по `fadeLevel` идёт плавный переход между активным и неактивным фоном;
- цвет текста выбирается автоматически:
  - тёмный фон → белый текст;
  - светлый фон → чёрный;
  - при disabled текст становится серым, но остаётся читаемым;
- если TTF‑шрифт для кнопок загружен, размер подбирается по высоте.

При `state.loading == true` кнопка визуально ведёт себя как отключённая (анимация нажатия блокируется), а сам текст `label` дополняется анимированными точками: `Label`, `Label.`, `Label..`, `Label...`, затем обратно. Эти точки добавляются автоматически внутри `drawButton` на основе времени (`millis()`), поэтому в коде достаточно передать базовый текст (`"Saving"`, `"Loading"` и т.п.).

---

# Переключатель

`ToggleSwitch` — компактный «переключатель» (ON/OFF) с плавной анимацией. Он состоит из двух частей:

- **[логика]** `updateToggleSwitch(...)` — обновляет состояние и анимацию;
- **[отрисовка]** `drawToggleSwitch(...)` — рисует трек и бегунок.

## 1. Состояние переключателя

```cpp
struct ToggleSwitchState
{
    bool value;          // текущее логическое состояние (ON/OFF)
    uint8_t pos;         // 0..255, позиция анимации (0 = OFF, 255 = ON)
    uint32_t lastUpdateMs;
};
```

Обычно достаточно объявить переменную и оставить её «по нулям»:

```cpp
static ToggleSwitchState sw;
```

## 2. Обновление (в `loop()`)

```cpp
bool updateToggleSwitch(ToggleSwitchState &s, bool pressed);
```

- **`pressed`**: событие короткого клика (например, `btnNext.wasPressed()`).
- Возвращает `true`, если:
  - состояние `value` поменялось
  - или анимация ещё продолжается (нужно продолжать перерисовывать кадры).

Типичный паттерн:

```cpp
bool changed = ui.updateToggleSwitch(sw, nextPressed);
if (changed)
    ui.requestRedraw();
```

## 3. Отрисовка (в screen-callback)

```cpp
void drawToggleSwitch(x, y, w, h,
                      ToggleSwitchState &state,
                      activeColor,
                      inactiveColor,
                      knobColor);
```

- `x/y/w/h` — позиция и размер. `x == center` / `y == center` центрируют элемент по доступной области экрана с учётом статус‑бара.
- `activeColor` — цвет трека в состоянии ON.
- `inactiveColor = -1` — авто‑цвет для OFF (на основе `activeColor`).
- `knobColor = -1` — авто‑цвет бегунка (контрастный к фону).

Пример экрана:

```cpp
void screenToggle(GUI &ui)
{
    uint16_t bg = ui.rgb(10, 10, 10);
    ui.clear(bg);

    ui.drawToggleSwitch(center, 150, 78, 36, sw, ui.rgb(21, 180, 110));
}
```

---

# Прогресс‑бар

В `GUI` есть готовый прямоугольный прогресс‑бар с аккуратными скруглениями и встроенными анимациями.

Есть две перегрузки:

```cpp
// Полный контроль над цветами
void drawProgressBar(
    x, y,               // x, y (center - выровнять по центру экрана)
    w, h,               // ширина/высота
    value,              // 0..100
    baseColor,          // цвет корпуса/подложки
    fillColor,          // цвет заливки
    radius = 8,         // радиус скругления
    anim                // тип анимации
);

// Упрощённый вариант: один основной цвет
void drawProgressBar(
     x, y,               // x, y (center - выровнять по центру экрана)
     w, h,               // ширина/высота
     value,              // 0..100
     color,              // основной цвет заливки
     radius = 8,         // радиус скругления
     anim                // тип анимации
);
```

Во второй перегрузке `baseColor` считается автоматически как слегка осветлённая версия `color`, поэтому достаточно одного оттенка.

При `x == center` / `y == center` прогресс‑бар центрируется по свободной области экрана, учитывая статус‑бар (как `drawGraphGrid`).

- **`anim`**
  - `None` - без анимации, просто заливка;
  - `Stripes` - бегущие диагональные полосы по заливке (эффект загрузки);
  - `Shimmer` - плавный светлый блик, который скользит по заливке (как в прогресс‑баре Windows);
  - `Indeterminate` - неопределённый прогресс: узкая цветная «полоса» бегает по всей длине бара, игнорируя `value` (подходит для состояний вида «загрузка...» без процента).

## Круговой прогресс‑бар

Для каждого режима `ProgressAnim` есть круговой (кольцевой) вариант.

Есть две перегрузки:

```cpp
// Полный контроль над цветами
void drawCircularProgressBar(
    x, y,               // x, y: центр кольца (center - авто‑центрирование с учётом статус‑бара)
    r,                  // радиус
    thickness,          // толщина кольца
    value,              // 0..100
    baseColor,          // цвет подложки (кольцо целиком)
    fillColor,          // цвет заполнения
    anim                // тип анимации (ProgressAnim)
);

// Упрощённый вариант: один основной цвет
void drawCircularProgressBar(
    x, y,               // x, y: центр кольца
    r,                  // радиус
    thickness,          // толщина кольца
    value,              // 0..100
    color,              // основной цвет заполнения
    anim                // тип анимации (ProgressAnim)
);
```

- При `anim == Indeterminate` параметр `value` игнорируется.
- При `x == center` / `y == center` кольцо центрируется по свободной области экрана, учитывая статус‑бар.

# Scroll dots (индикатор страниц)

`drawScrollDots()` рисует индикатор страниц/элементов: ряд точек и «активную капсулу».
Поддерживается простая анимация перехода между `prevIndex` и `activeIndex`.

```cpp
void drawScrollDots(
    x, y,                  // координаты (можно передать `center`)
    count,                 // количество точек (страниц)
    activeIndex,           // активная точка (0..count-1)
    prevIndex = 0,         // предыдущая точка (для анимации)
    animProgress = 0.0f,   // 0..1 прогресс анимации
    animate = false,       // true: рисовать анимированный переход
    animDirection = 0,     // направление анимации (-1/0/+1)
    activeColor = 0xFFFF,  // цвет активной «капсулы»
    inactiveColor = 0x7BEF,// цвет неактивных точек
    dotRadius = 3,         // радиус точки
    spacing = 14,          // шаг между центрами точек
    activeWidth = 18       // ширина активной «капсулы»
);
```

---

# Recovery Mode

Recovery Mode — это встроенный экран восстановления, который можно открыть **удержанием кнопки при старте**.
Идея: если прошивка загрузилась, но приложение «в плохом состоянии», пользователь может зайти в минимальное меню и выполнить действия вида сброса настроек/перезагрузки/сервиса.

## 1. Включение

В прошивке нужно передать `GUI` указатели на кнопки и (опционально) отдельную кнопку удержания:

```cpp
// Вариант 1: удержание одной из рабочих кнопок
ui.enableRecovery(&btnPrev, &btnNext, 900);

// Вариант 2: отдельная кнопка удержания
ui.enableRecovery(&btnPrev, &btnNext, &btnOk, 900);
```

После того как экран boot‑логотипа завершился, `GUI` начинает «армить» Recovery.
Если заданная кнопка удерживается `holdMs`, режим активируется.

## 2. Меню Recovery

Меню задаётся списком действий:

```cpp
ui.setRecoveryMenu({
    {"Restart",   "Reboot device",  [](GUI &ui) { /* reboot */ }},
    {"Safe mode", "Minimal boot",   [](GUI &ui) { /* ... */ }},
    {"Wipe",      "Reset settings", [](GUI &ui) { /* ... */ }},
});
```

- **`title`** — заголовок пункта.
- **`subtitle`** — подзаголовок/описание.
- **`action`** — колбэк, который вызовется при выборе пункта.

## 3. Управление в Recovery

Recovery использует те же две кнопки, что и обычные меню:

- **Prev**: вверх / назад.
- **Next**: вниз / выбор.

Пока Recovery активен, он сам читает кнопки и маршрутизирует ввод внутрь своего меню.

---

# Layout helpers (лёгкая раскладка)

Эти типы нужны, чтобы проще раскладывать UI без ручного пересчёта координат.
Это **не flexbox** и не «большая система», а набор простых helper‑ов.

## 1. Базовые структуры

```cpp
struct UiSize   { int16_t w, h; };
struct UiRect   { int16_t x, y, w, h; };
struct UiInsets { int16_t l, t, r, b; };
```

## 2. Slicing API (разрезание области)

`UiLayout` умеет «нарезать» область под блоки:

```cpp
UiRect root{0, 0, ui.width(), ui.height()};

UiRect work = UiLayout::inset(root, 10);
UiRect header = UiLayout::takeTop(work, 24, 8);   // верхняя панель + gap
UiRect footer = UiLayout::takeBottom(work, 28, 8);
UiRect content = work;                            // остаток
```

Доступные операции:

- `UiLayout::inset(rect, all)`
- `UiLayout::inset(rect, UiInsets{...})`
- `UiLayout::takeTop/Bottom/Left/Right(rect, size, gap)`

## 3. Flow API (равномерная раскладка по строке/колонке)

Если нужно разложить N элементов по строке/колонке с `gap` и выравниванием:

```cpp
UiSize sizes[3] = {{40, 20}, {60, 20}, {40, 20}};
UiRect out[3];

UiLayout::flowRow(area, sizes, out, 3, 10, UiJustify::Center, UiAlign::Center);
UiLayout::flowColumn(area, sizes, out, 3, 6, UiJustify::Start, UiAlign::Center);
```

- `UiJustify`: `Start/Center/End/SpaceBetween/SpaceEvenly`
- `UiAlign`: `Start/Center/End`

## 4. Cursor-based API (вариант 2)

Для более удобного кода без массивов можно использовать «курсорные» контейнеры.
Они собирают размеры через `next(...)`, а потом одним вызовом `finish()` вычисляют позиции.

```cpp
UiRect rowArea{10, 40, 220, 30};
UiFlowRow<3> row(rowArea, 10, UiJustify::SpaceBetween, UiAlign::Center);

row.next(40, 24);
row.next(60, 24);
row.next(40, 24);
row.finish();

// Теперь row[0], row[1], row[2] - готовые прямоугольники
```

Аналогично для колонок:

```cpp
UiFlowColumn<4> col(area, 6, UiJustify::Start, UiAlign::Center);
col.next(200, 18);
col.next(200, 18);
col.next(200, 18);
col.next(200, 18);
col.finish();
```

---

# Glow‑эффект (свечение) для фигур

В `GUI` есть две готовые функции, которые рисуют сглаженную фигуру и несколько полупрозрачных слоёв вокруг неё.

## 1. Круг

```cpp
void GUI::drawGlowCircle(
    x, y,                // координаты на экране, можно указать `center` (авто‑центрирование с учётом статус‑бара).
    r,                   // радиус круга.
    fillColor,           // цвет заливки.
    bgColor,             // цвет на для смешивания (если `-1`, берётся фон GUI).
    glowColor,           // цвет цвечения (если `-1`, выбирается автоматически на основе `fillColor`).
    glowSize,            // толщина/размер свечения в пикселях.
    glowStrength,        // сила свечения `0..255`.
    anim,                // тип анимации свечения (можно передавать `None` / `Pulse`).
    pulsePeriodMs        // период пульсации (мс), используется только при `Pulse`.
);
```

## 2. Скруглённый прямоугольник

```cpp
void GUI::drawGlowRoundRect(
    x, y,               // координаты на экране, можно указать `center` (авто‑центрирование с учётом статус‑бара).
    w, h,               // размеры
    radius,             // радиус скругления
    fillColor,          // цвет заливки.
    bgColor,            // цвет на для смешивания (если `-1`, берётся фон GUI).
    glowColor,          // цвет цвечения (если `-1`, выбирается автоматически на основе `fillColor`).
    glowSize,           // толщина/размер свечения в пикселях.
    glowStrength,       // сила свечения `0..255`.
    anim,               // тип анимации свечения (можно передавать `None` / `Pulse`).
    pulsePeriodMs       // период пульсации (мс), используется только при `Pulse`.
);
```

`GlowAnim`:

- `None` - без анимации;
- `Pulse` - плавное затухание/разгорание свечения (синус‑пульс).